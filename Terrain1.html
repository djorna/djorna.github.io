
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="" />

  <!-- link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet" --->
  <!-- link href="https://fonts.googleapis.com/css?family=Slabo+27px&display=swap" rel="stylesheet" --> 
  <!-- link href="https://fonts.googleapis.com/css?family=Lora&display=swap" rel="stylesheet" --> 
  <!--link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet" --> 
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet"> 

    <link rel="stylesheet" type="text/css" href="https://djorna.github.io/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="https://djorna.github.io/theme/pygments/github.min.css">
  <link rel="stylesheet" type="text/css" href="https://djorna.github.io/theme/font-awesome/css/font-awesome.min.css">





<!-- Google Analytics 
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-137157184-1', 'auto');
  ga('send', 'pageview');
</script>
End Google Analytics -->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-137157184-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-137157184-1');
</script>


<meta name="author" content="David Jorna" />
<meta name="description" content="Generate a 2D heightmap for use in 3D games and simulations." />
<meta name="keywords" content="Game Development, Projects, Terrain Generation">

<!-- MailChimp -->
<script id="mcjs">!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/2266395baae64c7ef988e2db5/55db5d385983164f1dadf9c8d.js");</script>

<meta property="og:site_name" content="David Jorna"/>
<meta property="og:title" content="Procedural Terrain Generation"/>
<meta property="og:description" content="Generate a 2D heightmap for use in 3D games and simulations."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="https://djorna.github.io/Terrain1.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2019-05-14 09:32:00-05:00"/>
<meta property="article:modified_time" content="2019-06-14 21:00:00-05:00"/>
<meta property="article:author" content="https://djorna.github.io/author/david-jorna.html">
<meta property="article:section" content="Open Source Projects"/>
<meta property="article:tag" content="Game Development"/>
<meta property="article:tag" content="Projects"/>
<meta property="article:tag" content="Terrain Generation"/>
<meta property="og:image" content="">

  <title>David Jorna &ndash; Procedural Terrain Generation</title>


  <!-- pelican_dynamic -->
</head>
<body>
  <aside>
    <div>
      <a href="https://djorna.github.io">
        <img src="https://djorna.github.io/theme/img/profile.png" alt="" title="">
      </a>
      <h1><a href="https://djorna.github.io"></a></h1>


      <nav>
        <ul class="list" id="navlinks">
            <li id="about"><a href="https://djorna.github.io/pages/about.html#about">About</a></li>

          <li id=""><a href="http://localhost:8000/tags.html">tags</a></li>
          <li id=""><a href="http://localhost:8000">blog</a></li>
        </ul>
      </nav>

    <!-- List categories  -->
    <!--
    <div class="category-cloud">
      <p>
        <a href="https://djorna.github.io/category/open-source-projects.html">Open Source Projects</a>
      </p>
    </div>
  -->

      <ul class="social">
        <li><a class="sc-linkedin" href="https://www.linkedin.com/in/david-jorna/" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        <li><a class="sc-github" href="https://github.com/djorna" target="_blank"><i class="fa fa-github"></i></a></li>
      </ul>

      <!-- a href="mailto:davidjorna@gmail.com?subject=Subscription to davidjorna.com
        &body=Hi, I would like to receive email notifications when you publish a new post.">Subscribe</a -->

      <!-- Begin Mailchimp Signup Form -->
      <!-- link href="//cdn-images.mailchimp.com/embedcode/classic-10_7.css" rel="stylesheet" type="text/css" -->

      <!-- form action="https://gmail.us20.list-manage.com/subscribe/post?u=2266395baae64c7ef988e2db5&amp;id=457c7cedd8" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
          < real people should not fill this in and expect good things - do not remove this or risk form bot signups>
          <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_2266395baae64c7ef988e2db5_457c7cedd8" tabindex="-1" value=""></div>
          <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="subscribe-button" class="button"></div>
      </form -->

<!--End mc_embed_signup-->

    
  <!--
   <ul class="list">
      <li><a href="https://djorna.github.io/category/open-source-projects.html">Open Source Projects</a> (1)</li>
    </ul> 
  -->

    </div>


  </aside>
  <main>


   
    <!-- <input type="button" onClick="subscribePopup()" value="Subscribe" />
    <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/unique-methods/embed.js" data-dojo-config="usePlainJson: true, isDebug: false">
    </script>
    <script type="text/javascript">
      window.dojoRequire(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us20.list-manage.com","uuid":"2266395baae64c7ef988e2db5","lid":"457c7cedd8","uniqueMethods":true}) })
    </script> -->

<article class="single">
  <header>
      
    <h1 id="Terrain1">Procedural Terrain Generation</h1>
    <p>
          Posted on Tue 14 May 2019 in <a href="https://djorna.github.io/category/open-source-projects.html">Open Source Projects</a>


        with tags
          <a href="https://djorna.github.io/tag/game-development.html">Game Development</a>,
          <a href="https://djorna.github.io/tag/projects.html">Projects</a>,
        <a href="https://djorna.github.io/tag/terrain-generation.html">Terrain Generation</a>

    </p>
    
  </header>
    <!-- Fancy math equations -->
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


  <div class="article-content">
    <h2>Motivation</h2>
<p>Procedural terrain generation encompasses a broad range of techniques, with the goal of efficiently creating a realistic simulated environment. Some of the most famous applications of procedural terrain generation are in <a href="https://www.minecraft.net/en-us/">Minecraft</a>, which procedurally generated biomes to simulate different climages, and <a href="https://www.nomanssky.com/">No Man's Sky</a>, which uses procedural techniques to generate entire worlds.</p>
<p>While video games are the most well-known application of procedural terrain generation, they are not the only application. Recently, OpenAI has demonstrated the utility of training robots in a simulation before deploying them in the real world, using deep reinforcement learning. So far, the focus has mostly been on teaching robotic manipulators complex tasks, but the same algorithms could also be used to train self-driving cars, and other forms of mobile robots. The challenge with this approach is that we have to build hundreds of kilometers of photorealistic roads for the cars to drive on. Perhaps in the future, some kind of procedural world generation will be used to train and test self-driving cars and other robots.</p>
<!--
## Contents
[Diamond-Square Algorithm](#the-diamond-square-algorithm) 
[Voronoi Diagrams](#voronoi-diagrams)  
[Weighted Combination](#weighted-combination)  
[Thermal Erosion](#thermal-erosion)  
[Hydraulic Erosion](#hydraulic-erosion)  
[Unity Plugin Demo](#unity-plugin)  
[Further Reading](#further-reading)
-->

<h2>The Diamond-Square Algorithm</h2>
<p>The algorithm for terrain generation that we're going to use is called the <a href="https://en.wikipedia.org/wiki/Diamond-square_algorithm">diamond-square algorithm</a>. It's a fairly simple algorithm that consists of alternately performing "square" and "diamond" operations on a 2D grid. These steps are best explained graphically.</p>
<p><img alt="diamond-square algorithm graphic" src="images/1200px-Diamond_Square.svg.png">
<em>A graphical illustration of the diamond-square algorithm. Photo credit: Christopher Ewin, <a href="https://creativecommons.org/licenses/by-sa/4.0" title="Creative Commons Attribution-Share Alike 4.0">CC BY-SA 4.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=42510593">Link</a></em></p>
<p>The algorithm looks something like this:  </p>
<ol>
<li>Set persistence between 0 and 1</li>
<li>Set corners to random values</li>
<li>Set the offset range to 1.</li>
<li>(Diamond step) Set the center of the diamond to the average of the diamond corner values, plus a random offset within the offset range.</li>
<li>(Square step) Set the center of the square to the average of the square corner values, plus a random offset within the offset range.</li>
<li>Halve the step size of the diamonds and squares.</li>
<li>Multiply the offset range by the persistence.</li>
<li>Repeat steps 4-&gt;7 until every cell value has been calculated.</li>
</ol>
<p>Higher values of the "persistence" parameter make the output more noisy, and lower values make it smoother. This make sense, because for lower persistence values, the cell values depend on each other more.</p>
<p><img alt="diamond_square_demo" src="images/diamond_square.png"></p>
<h2>Voronoi Diagrams</h2>
<p>Voronoi diagrams are 2D maps split into polygonal regions based on their proximity to random points. They are easiest to understand with visuals.</p>
<p><img alt="voronoi_diagram" src="images/voronoi_colour.png">
<em>An illustration of a Voronoi diagram with cell regions coloured based on their nearest neighbour.</em></p>
<p>Voronoi diagrams have many interesting applications, including urban planning, robotics, and of course procedural generation. There are some interesting algorithms for generating Voronoi diagrams, but we won't be using them, because they mostly focus on calculating the edges of the diagram, which is not the information we're looking for. Instead, we need the </p>
<p>For this application, we want to adjust the height of each cell based on their \(n^{th}\) nearest neighbours. In this case it makes sense to use the kd-tree data structure to allow for fast searching of nearest neighbours.</p>
<p>The heights of each cell will be calculated as a linear combination of its nearest neighbours \(h = c_1 h_1 + c_2 h_2 ... + c_n h_n\), where \(h_i\) is the \(n^{th}\) nearest neighbour and the coefficients \(c_i\) are parameters which can be adjusted to achieve different effects.</p>
<p><img alt="voronoi_demo" src="images/voronoi.png"><br>
<em>Generated Voronoi diagram with the parameters \(n_{peaks} = 20, c_1 = -1, c_2 = 1\).</em></p>
<h3>Modifications</h3>
<p>Since the Voronoi diagrams are based on random points, the user has very little control over it, and... </p>
<h2>Weighted Combination</h2>
<p>The Voronoi diagram can be used to simulate mountains, but they are too smooth to emulate real terrain. To remedy this, we will set the new terrain \(C\) to be a linear combination of the diamond-square heightmap, \(D\), and the Voronoi heightmap, \(V\). The parameter \(\alpha \) is some real number between 0 and 1.</p>
<p>\[\renewcommand{\vec}[1]{\mathbf{#1}}\]
\[\vec{C} := \alpha \vec{D} + (1 - \alpha) \vec{V}\]
Here's what the heightmap looks like with \(\alpha\ = 0.66\), meaning the ratio of the diamond-square heightmap to the Voronoi heightmap is 2:1:</p>
<p><img alt="combined" src="images/combined.png">
<em>Combined heightmap with \(\alpha = 0.66\).</em></p>
<h2>Perturbation Filter</h2>
<p>This one was a pain in the neck to figure out. The algorithm wasn't given in the paper, and instead a link to a textbook <em><a href="https://www.amazon.com/Texturing-Modeling-Third-Procedural-Approach/dp/1558608486">(Texturing and Modeling: a Procedural Approach Third Edition)</a></em> was given. So I found the excerpt from the book on Google Books, and it used a shader language (Renderman Shader Language), which I wasn't familiar with. But after banging my head against the desk a bit, I was able to get something that has some resemblance to the figure in the paper.</p>
<p>The "perturbation filter" described in this paper uses a well-known algorithm in procedural generation: <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</a>. Perlin noise works by generating an n-dimensional displacement field, so each cell is displaced by a random amount. For this application, we will use 3D Perlin noise, and calculate the displacement of each pixel based on its initial position \( (i, j) \), and pixel value \(h_{i,j}\).</p>
<p><img alt="perturb_demo" src="images/perturb.png">
<em>The combined heightmap is warped with a perturbation filter with a magnitude of 0.02. This mean that the most any pixel can be displaced in \(0.02 N\), where \(N\) is the side length of the heightmap.</em></p>
<h2>Thermal Erosion</h2>
<p>Something to keep in mind with erosion algorithms is that the goal is not necessarily to simulate natural processes. We just want the end result to look right, and the algorithm to be efficient. In computer graphics, there is no such thing as cheating.</p>
<!--
The pseudocode for thermal erosion is as follows:

wzxhzdk:0

-->

<p>\[h_i := h_i + c (d_{max} - T) \times \frac{d_i}{d_{total}} , \enspace   \forall d_i &gt; T\]</p>
<p>Where:<br>
\(T\) is the talus angle parameter, which represents the point at which ...<br>
\(c\) is the erosion magnitude. 
\(h_i\) is the \(i^{th}\) neighbour of \(h\)<br>
\(d_i = h - h_i \) is the height difference between the 
\(d_{total} = \sum\limits_{i} d_i \quad  \forall d_i &gt; T \)  </p>
<p><img alt="thermal_erosion_demo" src="images/thermal_erosion_eroded.png"><br>
<em>Thermal erosion run for 50 iterations.</em></p>
<h2>Hydraulic Erosion</h2>
<p>Hydraulic erosion is more demanding on both memory and computation than thermal erosion, because it involves keeping track of a water layer as well as the sediment layer. Hydraulic erosion consists of 4 steps:</p>
<h3>1. Rainfall</h3>
<p>Add a constant value to each cell of the watermap to simulate rainfall.</p>
<p>\[\vec{W} := \vec{W} + K_{r} \]</p>
<p>Where \(\vec{W}\) is the watermap and \(K_r\) is the rain constant.</p>
<h3>3. Erosion</h3>
<p>\[\vec{H} := \vec{H} - K_{s} \vec{W} \]
\[\vec{S} := \vec{S} + K_{s} \vec{W} \]</p>
<p>Where \(H\) is the heightmap, \(S\) is the sediment map, and \(K_s\) is the sediment coefficient.</p>
<h3>4. Transportation</h3>
<p>Water tends to In mathematical terms, this mean that at each cell, the total value of \(a = h + w\) should be levelled out with respect to its neighbours. This gives us the formulas:</p>
<p>\[\Delta w_i = min(w, \Delta a) \times \frac{d_i}{d_{total}} \]</p>
<p>Where \( \Delta w_i\) is the amount for water transferred from \(w\) to each neighbouring cell \(w_i\).</p>
<p>And since the flow of water will have an effect on the loose sediment, the sediment flow will be proportional to the water flow:</p>
<p>\[\Delta s_i = s \times \frac{\Delta w_i}{w} \]</p>
<p>Where \( \Delta s_i\) is the amount for sediment transferred from \(s\) to each neighbouring cell \(s_i\).</p>
<h3>5. Evaporation</h3>
<p>First, a percentage of the water is evaporated.
\[\vec{W} := (1 - K_e) \vec{W}  \]
Where \(K_e\) is the evaporation coefficient.</p>
<p>Finally, some amount of sediment, \(\delta s_{max}\) will remain within the water, based on the sediment capacity of the water \(K_s\), and some will fall, and be recombined with the heightmap. \(\delta s_{max}\) is calculated as:<br>
\[\delta s_{max} = K_c \times w\]</p>
<p>And the remaining sediment is recombined with the heightmap:</p>
<p>\[\Delta s := max(0, s - \delta m_{max})\]
\[s := s - \Delta s\]
\[h := h + \Delta s\]</p>
<p>The coefficients used in the paper are as follows:  </p>
<p>\(K_r = 0.01\)<br>
\(K_s = 0.01\)<br>
\(K_e = 0.5\)<br>
\(K_c = 0.01\)</p>
<p><img alt="hydraulic_erosion_demo" src="images/hydraulic_erosion_eroded.png"></p>
<h2>Unity Plugin</h2>
<p>In order to visualize the generated terrain in 3D, and provide a simpler user interface, I wrote a Unity3D plugin for the library. I plan to put it on the Asset Store eventually, but for now here are some visualizations of the plugin's functionality.</p>
<p><img alt="diamond-square-unity" src="https://j.gifs.com/Gv94v8.gif"><br>
<em>This animation shows the result of the diamond square algorithm being run with varying values of \(p\). As persistence increases, the heightmap looks noisier.</em></p>
<p><img alt="voronoi-unity" src="https://j.gifs.com/JyP582.gif"><br>
<em>The Voronoi diagram is generated with parameters \(n_{peaks}\), and style coefficients \(c_1 ... c_n\). Individual modification of each peak is possible with the addition of multipliers for each individual peak.</em></p>
<p><img alt="voronoi-modes-unity" src="https://j.gifs.com/3Q9W6M.gif"><br>
<em>The Voronoi coefficients \(c_1 ... c_n\), can be modified to create different effects. The parameters shown here are, in order: \( (c_1 = -1, c_2 = 1 )\) (the standard parameters used in the paper to create mountains), \( (c_1 = 1) \), \( (c_1 = 0, c_2 = 1) \), and  \( (c_1 = 0, c_2 = 0, c_3 = 1) \).</em></p>
<p><img alt="combination-unity" src="https://j.gifs.com/zvnZ7Y.gif"><br>
<em>The diamond-square heightmap is combined with the Voronoi heightmap using a heighted average. The gif shows the results of adjusting the weight parameter \(\alpha\). The value of the heightmap is \(\alpha D + (1 - \alpha) V\) where \(D\) and \(V\) are the diamond-square and Voronoi heightmaps, respectively.</em></p>
<p><img alt="perturbation-unity" src="https://j.gifs.com/lxpG76.gif"><br>
<em><a href="https://en.wikipedia.org/wiki/Simplex_noise">Simplex noise</a> is used to create a gradient field, which distorts the heightmap, making it less uniform and boxy.</em></p>
<p><img alt="fast-erosion-unity" src="https://j.gifs.com/6X0Z09.gif"><br>
<em>A demonstration of Jacob Olsen's speed-optimized version of thermal erosion.</em></p>
<p>You can find the full source code for this project on <a href="https://github.com/djorna/terrain-generation">my Github page</a>.</p>
<h2>Further Reading</h2>
<p>All of the techniques I am using for procedural terrain generation are from a <a href="http://web.mit.edu/cesium/Public/terrain.pdf">2004 paper</a>, which details the use of the algorithm to generate maps for a real-time strategy game. I highly recommend reading the paper, as it goes into more depth about the design and optimization of each of the algorithms.</p>
  </div>

  

  <!-- Show tag cloud
  <div class="tag-cloud">
    <p>
      <a href="https://djorna.github.io/tag/game-development.html">Game Development</a>
      <a href="https://djorna.github.io/tag/projects.html">Projects</a>
      <a href="https://djorna.github.io/tag/terrain-generation.html">Terrain Generation</a>
    </p>
  </div>
  -->





  <!-- Commento -->
  <div id="commento"></div><script src="https://cdn.commento.io/js/commento.js"></script>
  <!-- include "partial/disqus.html" %} -->
</article>

    <footer>

<p>&copy; David Jorna 2019</p>
    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " David Jorna ",
  "url" : "https://djorna.github.io",
  "image": "",
  "description": ""
}
</script>


  <!--style>
    a.active {
      color:#0066ff;
    }
  </style--->
  
  <script>
  // Script for highlighting menu options
  var items = document.getElementById("navlinks").getElementsByTagName("li");
  for (var i = 0; i < items.length; ++i) {
    var link = items[i].getElementsByTagName("a").item(0);
    if (link == document.URL) {
      link.className = 'active';
    }
  }
  </script>
</body>

</html>